#
#
#
#
#

Partitions：
 好处：
  1.提高可用性。查询优化器自动移除未引用的分区，查询时不影响分区不可用
  2.易于管理模式对象。DDL可以操作一个分区而不是整张表或者索引，删除分区可以避免删除大量的行。
  3.减少OLTP中资源争用的问题。分区表是每个分区都占一个段，DML分布在许多段中而不是一个段。
  4.数据仓库中查询性能的提高。
  
分区策略：
 range：
 CREATE TABLE time_range_sales
   ( prod_id        NUMBER(6)
   , cust_id        NUMBER
   , time_id        DATE
   , channel_id     CHAR(1)
   , promo_id       NUMBER(6)
   , quantity_sold  NUMBER(3)
   , amount_sold    NUMBER(10,2)
   )
PARTITION BY RANGE (time_id)
 (PARTITION SALES_1998 VALUES LESS THAN (TO_DATE('01-JAN-1999','DD-MON-YYYY')),
  PARTITION SALES_1999 VALUES LESS THAN (TO_DATE('01-JAN-2000','DD-MON-YYYY')),
  PARTITION SALES_2000 VALUES LESS THAN (TO_DATE('01-JAN-2001','DD-MON-YYYY')),
  PARTITION SALES_2001 VALUES LESS THAN (MAXVALUE)
 ); 
 
 
 list：
 CREATE TABLE list_sales
   ( prod_id        NUMBER(6)
   , cust_id        NUMBER
   , time_id        DATE
   , channel_id     CHAR(1)
   , promo_id       NUMBER(6)
   , quantity_sold  NUMBER(3)
   , amount_sold    NUMBER(10,2)
   )
PARTITION BY LIST (channel_id)
 (PARTITION even_channels VALUES (2,4),
  PARTITION odd_channels VALUES (3,9)
 ); 
 
 
 hash：
 CREATE TABLE hash_sales
   ( prod_id        NUMBER(6)
   , cust_id        NUMBER
   , time_id        DATE
   , channel_id     CHAR(1)
   , promo_id       NUMBER(6)
   , quantity_sold  NUMBER(3)
   , amount_sold    NUMBER(10,2)
   )
PARTITION BY HASH (prod_id)
PARTITIONS 2; 
 
 如果改变分区的数量，那么数据库将重新分配数据。
 即使分区表只有一个分区，也跟普通表不同，因为分区表可以增加分区，而普通表不可以。
 分区表的每一个分区都独占一个段。
 表的压缩属性可以为表空间，表，表分区声明。
 
 分区索引：
  local partition index：
   局部分区索引，只索引该分区。局部分区索引的优点是增加可用性和便于维护。可用性增加是因为只要维护该分区，便于维护是因为当移动分区时，必须要重建或者维护关联的本地索引，
   CREATE INDEX hash_sales_idx ON hash_sales(time_id) LOCAL;
   hash_sales 有两个分区，创建局部分区索引时，hash_sales_idx也会有两个分区。
 
 globale partition index：
   全局分区索引，
 
 compisite：
 
