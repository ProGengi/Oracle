#
#
#
#
#

索引存储的是该列的值以及rowid，按照一定顺序存储。
树形结构，分支块存储索引块的数据，叶子块存储数据块的数据。使用索引时，至少要访问树的高度加一个块。

索引扫描的类型：
 索引范围扫描：
   当谓语中包含将返回一定范围数据的条件时，就会选用索引范围扫描。所指定的条件可以是>,<,like,between,甚至=，但是范围越大，就越可能全表扫描。
 索引唯一扫描：
   在谓语中使用unique或者primarykey作为条件时，就会选用索引唯一扫描。能够保证某个特定的值能够返回一行。
 索引全扫描：
   当没有谓语，但是所需列表可以通过一列的索引来获得。
   谓语中中包含一个索引中非引导列上的条件，或者数据可以通过一个排过序的索引来获取并且会省去单独的排序步骤。
 索引跳跃扫描：
   当谓语中包含位于索引中非引导列上的条件，并且引导列的值是唯一的时候会选择索引跳跃扫描。
 索引快速全扫描：
   



Oracle索引
 1.B-tree index(balance tree)：构造类似于二叉树
  储存rowid以及键值。在非唯一索引中，数据先安键值排序然后按照rowid排序。在唯一索引中，数据直接按照键值排序。
  b树索引所有叶子子块都应该在树的同一层上，这一层也称树的高度，所从根遍历到叶子块都会访问相同数目的块。
  大多数B-tree索引的高度都为2或者3，即使索引中有数百万记录也是如此。因此在索引中找到一个键只要2~3次I/O。
  如果所访问的行太多(所占比多于20%),与全表扫描相比，B树索引要花费更多的时间。
  
 2.descending index：降序索引，索引默认按照升序存储。
   create index idx_t on t(A desc);
 3.reverse key index(反向键索引):
   这也是B树索引，只是将键的值反转了。用于减少右侧中对索引块的竞争。
   反向键索引的范围扫描不能使用范围运算符，between，>,<等。
   
 4.function-based index(基于函数的索引):
   create index idx_t on emp(upper(ename));
   
 5.application domain index(应用域索引)：

 6.bitmap index(位图索引):适合建立在高度重复且值较少的列。
   如100万行，只有Y,N,NULL三个值且均匀分布时。但是，如果100万行，只有几百行是Y,剩下的都是N的情况就不适合建立位图索引。
   位图索引特别不适用于OLTP系统，也不适用多个会话频繁更新。除了位图索引其他索引都是基于B树的。
   create bitmap index idx_t on t(A);
 7.虚拟索引：
   虚拟索引没有相关的存储空间，因此也叫无段索引。
   alter session set "_use_nosegment_indexes" = true; --默认是是false，优化器不会选择。

 8.组合索引
   在多列上建的索引就是组合索引。
   当在谓语中使用组合索引的所有列时，会走索引，在谓语中使用引导列(即组合索引的第一列)时也走索引，其他不走索引。
   在谓语中只使用组合索引的引导列时，虽然走索引，但是效率没有在该列上建单个索引高。
   创建组合索引时，等值量少的列应该作为引导列。
   

选择建索引的列：
 1.该列上使用了等式或者范围谓语
 2.一张表中基数低的列更适合当索引。假设表中100万行数据，A列100个唯一值，在A列上的基数就是100万/100=10000。B列200个唯一值，B列上的基数就是5000.所以B列比A列更适合当索引。
 3.索引的成本，插入，删除，以及更新都需要维护索引。
 
空值问题：
 空值不存储单列索引上，但是存储在多列索引上。
 create index idx_t1 on t1(n1,0); --当where条件是 n1 is null 时，也可走索引。

分区索引：
 1.在分区表上可以创建局部或者全局索引。
   局部索引：
    使用local关键字来建立。
    如果局部索引包含分区键，在谓语中使用了分区键，那么就会产生分区消除，性能就会提升。
   全局索引：
    使用global关键字来建立。
    
